{"version":3,"file":"schema-object.mjs","sources":["../../src/transform/schema-object.ts"],"sourcesContent":["import { parseRef } from \"@redocly/openapi-core/lib/ref-utils.js\";\nimport ts from \"typescript\";\nimport {\n  BOOLEAN,\n  NEVER,\n  NULL,\n  NUMBER,\n  QUESTION_TOKEN,\n  STRING,\n  UNDEFINED,\n  UNKNOWN,\n  addJSDocComment,\n  oapiRef,\n  tsArrayLiteralExpression,\n  tsEnum,\n  tsIntersection,\n  tsIsPrimitive,\n  tsLiteral,\n  tsModifiers,\n  tsNullable,\n  tsOmit,\n  tsPropertyIndex,\n  tsRecord,\n  tsUnion,\n  tsWithRequired,\n} from \"../lib/ts.js\";\nimport { createDiscriminatorProperty, createRef, getEntries } from \"../lib/utils.js\";\nimport type { ReferenceObject, SchemaObject, TransformNodeOptions } from \"../types.js\";\n\n/**\n * Transform SchemaObject nodes (4.8.24)\n * @see https://spec.openapis.org/oas/v3.1.0#schema-object\n */\nexport default function transformSchemaObject(\n  schemaObject: SchemaObject | ReferenceObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  const type = transformSchemaObjectWithComposition(schemaObject, options);\n  if (typeof options.ctx.postTransform === \"function\") {\n    const postTransformResult = options.ctx.postTransform(type, options);\n    if (postTransformResult) {\n      return postTransformResult;\n    }\n  }\n  return type;\n}\n\n/**\n * Transform SchemaObjects\n */\nexport function transformSchemaObjectWithComposition(\n  schemaObject: SchemaObject | ReferenceObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  /**\n   * Unexpected types & edge cases\n   */\n\n  // missing/falsy type returns `never`\n  if (!schemaObject) {\n    return NEVER;\n  }\n  // `true` returns `unknown` (this exists, but is untyped)\n  if ((schemaObject as unknown) === true) {\n    return UNKNOWN;\n  }\n  // for any other unexpected type, throw error\n  if (Array.isArray(schemaObject) || typeof schemaObject !== \"object\") {\n    throw new Error(\n      `Expected SchemaObject, received ${Array.isArray(schemaObject) ? \"Array\" : typeof schemaObject} at ${options.path}`,\n    );\n  }\n\n  /**\n   * ReferenceObject\n   */\n  if (\"$ref\" in schemaObject) {\n    return oapiRef(schemaObject.$ref);\n  }\n\n  /**\n   * const (valid for any type)\n   */\n  if (schemaObject.const !== null && schemaObject.const !== undefined) {\n    return tsLiteral(schemaObject.const);\n  }\n\n  /**\n   * enum (non-objects)\n   * note: enum is valid for any type, but for objects, handle in oneOf below\n   */\n  if (\n    Array.isArray(schemaObject.enum) &&\n    (!(\"type\" in schemaObject) || schemaObject.type !== \"object\") &&\n    !(\"properties\" in schemaObject) &&\n    !(\"additionalProperties\" in schemaObject)\n  ) {\n    // hoist enum to top level if string/number enum and option is enabled\n    if (\n      options.ctx.enum &&\n      schemaObject.enum.every((v) => typeof v === \"string\" || typeof v === \"number\" || v === null)\n    ) {\n      let enumName = parseRef(options.path ?? \"\").pointer.join(\"/\");\n      // allow #/components/schemas to have simpler names\n      enumName = enumName.replace(\"components/schemas\", \"\");\n      const metadata = schemaObject.enum.map((_, i) => ({\n        name: schemaObject[\"x-enum-varnames\"]?.[i] ?? schemaObject[\"x-enumNames\"]?.[i],\n        description: schemaObject[\"x-enum-descriptions\"]?.[i] ?? schemaObject[\"x-enumDescriptions\"]?.[i],\n      }));\n\n      // enums can contain null values, but dont want to output them\n      let hasNull = false;\n      const validSchemaEnums = schemaObject.enum.filter((enumValue) => {\n        if (enumValue === null) {\n          hasNull = true;\n          return false;\n        }\n\n        return true;\n      });\n      const enumType = tsEnum(enumName, validSchemaEnums as (string | number)[], metadata, {\n        shouldCache: options.ctx.dedupeEnums,\n        export: true,\n        // readonly: TS enum do not support the readonly modifier\n      });\n      if (!options.ctx.injectFooter.includes(enumType)) {\n        options.ctx.injectFooter.push(enumType);\n      }\n      const ref = ts.factory.createTypeReferenceNode(enumType.name);\n      return hasNull ? tsUnion([ref, NULL]) : ref;\n    }\n    const enumType = schemaObject.enum.map(tsLiteral);\n    if ((Array.isArray(schemaObject.type) && schemaObject.type.includes(\"null\")) || schemaObject.nullable) {\n      enumType.push(NULL);\n    }\n\n    const unionType = tsUnion(enumType);\n\n    // hoist array with valid enum values to top level if string/number enum and option is enabled\n    if (options.ctx.enumValues && schemaObject.enum.every((v) => typeof v === \"string\" || typeof v === \"number\")) {\n      let enumValuesVariableName = parseRef(options.path ?? \"\").pointer.join(\"/\");\n      // allow #/components/schemas to have simpler names\n      enumValuesVariableName = enumValuesVariableName.replace(\"components/schemas\", \"\");\n      enumValuesVariableName = `${enumValuesVariableName}Values`;\n\n      const enumValuesArray = tsArrayLiteralExpression(\n        enumValuesVariableName,\n        oapiRef(options.path ?? \"\"),\n        schemaObject.enum as (string | number)[],\n        {\n          export: true,\n          readonly: true,\n          injectFooter: options.ctx.injectFooter,\n        },\n      );\n\n      options.ctx.injectFooter.push(enumValuesArray);\n    }\n\n    return unionType;\n  }\n\n  /**\n   * Object + composition (anyOf/allOf/oneOf) types\n   */\n\n  /** Collect oneOf/anyOf */\n  function collectUnionCompositions(items: (SchemaObject | ReferenceObject)[]) {\n    const output: ts.TypeNode[] = [];\n    for (const item of items) {\n      output.push(transformSchemaObject(item, options));\n    }\n\n    return output;\n  }\n\n  /** Collect allOf with Omit<> for discriminators */\n  function collectAllOfCompositions(items: (SchemaObject | ReferenceObject)[], required?: string[]): ts.TypeNode[] {\n    const output: ts.TypeNode[] = [];\n    for (const item of items) {\n      let itemType: ts.TypeNode;\n      // if this is a $ref, use WithRequired<X, Y> if parent specifies required properties\n      // (but only for valid keys)\n      if (\"$ref\" in item) {\n        itemType = transformSchemaObject(item, options);\n\n        const resolved = options.ctx.resolve<SchemaObject>(item.$ref);\n\n        // make keys required, if necessary\n        if (\n          resolved &&\n          typeof resolved === \"object\" &&\n          \"properties\" in resolved &&\n          // we have already handled this item (discriminator property was already added as required)\n          !options.ctx.discriminators.refsHandled.includes(item.$ref)\n        ) {\n          // add WithRequired<X, Y> if necessary\n          const validRequired = (required ?? []).filter((key) => !!resolved.properties?.[key]);\n          if (validRequired.length) {\n            itemType = tsWithRequired(itemType, validRequired, options.ctx.injectFooter);\n          }\n        }\n      }\n      // otherwise, if this is a schema object, combine parent `required[]` with its own, if any\n      else {\n        const itemRequired = [...(required ?? [])];\n        if (typeof item === \"object\" && Array.isArray(item.required)) {\n          itemRequired.push(...item.required);\n        }\n        itemType = transformSchemaObject({ ...item, required: itemRequired }, options);\n      }\n\n      const discriminator =\n        (\"$ref\" in item && options.ctx.discriminators.objects[item.$ref]) || (item as any).discriminator;\n      if (discriminator) {\n        output.push(tsOmit(itemType, [discriminator.propertyName]));\n      } else {\n        output.push(itemType);\n      }\n    }\n    return output;\n  }\n\n  // compile final type\n  let finalType: ts.TypeNode | undefined = undefined;\n\n  // core + allOf: intersect\n  const coreObjectType = transformSchemaObjectCore(schemaObject, options);\n  const allOfType = collectAllOfCompositions(schemaObject.allOf ?? [], schemaObject.required);\n  if (coreObjectType || allOfType.length) {\n    const allOf: ts.TypeNode | undefined = allOfType.length ? tsIntersection(allOfType) : undefined;\n    finalType = tsIntersection([...(coreObjectType ? [coreObjectType] : []), ...(allOf ? [allOf] : [])]);\n  }\n  // anyOf: union\n  // (note: this may seem counterintuitive, but as TypeScriptâ€™s unions are not true XORs, they mimic behavior closer to anyOf than oneOf)\n  const anyOfType = collectUnionCompositions(schemaObject.anyOf ?? []);\n  if (anyOfType.length) {\n    finalType = tsUnion([...(finalType ? [finalType] : []), ...anyOfType]);\n  }\n  // oneOf: union (within intersection with other types, if any)\n  const oneOfType = collectUnionCompositions(\n    schemaObject.oneOf ||\n      (\"type\" in schemaObject &&\n        schemaObject.type === \"object\" &&\n        (schemaObject.enum as (SchemaObject | ReferenceObject)[])) ||\n      [],\n  );\n  if (oneOfType.length) {\n    // note: oneOf is the only type that may include primitives\n    if (oneOfType.every(tsIsPrimitive)) {\n      finalType = tsUnion([...(finalType ? [finalType] : []), ...oneOfType]);\n    } else {\n      finalType = tsIntersection([...(finalType ? [finalType] : []), tsUnion(oneOfType)]);\n    }\n  }\n\n  // When no final type can be generated, fall back to unknown type (or related variants)\n  if (!finalType) {\n    if (\"type\" in schemaObject) {\n      finalType = tsRecord(STRING, options.ctx.emptyObjectsUnknown ? UNKNOWN : NEVER);\n    } else {\n      finalType = UNKNOWN;\n    }\n  }\n\n  if (finalType !== UNKNOWN && schemaObject.nullable) {\n    finalType = tsNullable([finalType]);\n  }\n\n  return finalType;\n}\n\n/**\n * Handle SchemaObject minus composition (anyOf/allOf/oneOf)\n */\nfunction transformSchemaObjectCore(schemaObject: SchemaObject, options: TransformNodeOptions): ts.TypeNode | undefined {\n  if (\"type\" in schemaObject && schemaObject.type) {\n    if (typeof options.ctx.transform === \"function\") {\n      const result = options.ctx.transform(schemaObject, options);\n      if (result && typeof result === \"object\") {\n        if (\"schema\" in result) {\n          if (result.questionToken) {\n            return ts.factory.createUnionTypeNode([result.schema, UNDEFINED]);\n          } else {\n            return result.schema;\n          }\n        } else {\n          return result;\n        }\n      }\n    }\n\n    // primitives\n    // type: null\n    if (schemaObject.type === \"null\") {\n      return NULL;\n    }\n    // type: string\n    if (schemaObject.type === \"string\") {\n      return STRING;\n    }\n    // type: number / type: integer\n    if (schemaObject.type === \"number\" || schemaObject.type === \"integer\") {\n      return NUMBER;\n    }\n    // type: boolean\n    if (schemaObject.type === \"boolean\") {\n      return BOOLEAN;\n    }\n\n    // type: array (with support for tuples)\n    if (schemaObject.type === \"array\") {\n      // default to `unknown[]`\n      let itemType: ts.TypeNode = UNKNOWN;\n      // tuple type\n      if (schemaObject.prefixItems || Array.isArray(schemaObject.items)) {\n        const prefixItems = schemaObject.prefixItems ?? (schemaObject.items as (SchemaObject | ReferenceObject)[]);\n        itemType = ts.factory.createTupleTypeNode(prefixItems.map((item) => transformSchemaObject(item, options)));\n      }\n      // standard array type\n      else if (schemaObject.items) {\n        if (hasKey(schemaObject.items, \"type\") && schemaObject.items.type === \"array\") {\n          itemType = ts.factory.createArrayTypeNode(transformSchemaObject(schemaObject.items, options));\n        } else {\n          itemType = transformSchemaObject(schemaObject.items, options);\n        }\n      }\n\n      const min: number =\n        typeof schemaObject.minItems === \"number\" && schemaObject.minItems >= 0 ? schemaObject.minItems : 0;\n      const max: number | undefined =\n        typeof schemaObject.maxItems === \"number\" && schemaObject.maxItems >= 0 && min <= schemaObject.maxItems\n          ? schemaObject.maxItems\n          : undefined;\n      const estimateCodeSize = typeof max !== \"number\" ? min : (max * (max + 1) - min * (min - 1)) / 2;\n      if (\n        options.ctx.arrayLength &&\n        (min !== 0 || max !== undefined) &&\n        estimateCodeSize < 30 // \"30\" is an arbitrary number but roughly around when TS starts to struggle with tuple inference in practice\n      ) {\n        if (min === max) {\n          const elements: ts.TypeNode[] = [];\n          for (let i = 0; i < min; i++) {\n            elements.push(itemType);\n          }\n          return tsUnion([ts.factory.createTupleTypeNode(elements)]);\n        } else if ((schemaObject.maxItems as number) > 0) {\n          // if maxItems is set, then return a union of all permutations of possible tuple types\n          const members: ts.TypeNode[] = [];\n          // populate 1 short of min â€¦\n          for (let i = 0; i <= (max ?? 0) - min; i++) {\n            const elements: ts.TypeNode[] = [];\n            for (let j = min; j < i + min; j++) {\n              elements.push(itemType);\n            }\n            members.push(ts.factory.createTupleTypeNode(elements));\n          }\n          return tsUnion(members);\n        }\n        // if maxItems not set, then return a simple tuple type the length of `min`\n        else {\n          const elements: ts.TypeNode[] = [];\n          for (let i = 0; i < min; i++) {\n            elements.push(itemType);\n          }\n          elements.push(ts.factory.createRestTypeNode(ts.factory.createArrayTypeNode(itemType)));\n          return ts.factory.createTupleTypeNode(elements);\n        }\n      }\n\n      const finalType =\n        ts.isTupleTypeNode(itemType) || ts.isArrayTypeNode(itemType)\n          ? itemType\n          : ts.factory.createArrayTypeNode(itemType); // wrap itemType in array type, but only if not a tuple or array already\n\n      return options.ctx.immutable\n        ? ts.factory.createTypeOperatorNode(ts.SyntaxKind.ReadonlyKeyword, finalType)\n        : finalType;\n    }\n\n    // polymorphic, or 3.1 nullable\n    if (Array.isArray(schemaObject.type) && !Array.isArray(schemaObject)) {\n      // skip any primitive types that appear in oneOf as well\n      const uniqueTypes: ts.TypeNode[] = [];\n      if (Array.isArray(schemaObject.oneOf)) {\n        for (const t of schemaObject.type) {\n          if (\n            (t === \"boolean\" || t === \"string\" || t === \"number\" || t === \"integer\" || t === \"null\") &&\n            schemaObject.oneOf.find((o) => typeof o === \"object\" && \"type\" in o && o.type === t)\n          ) {\n            continue;\n          }\n          uniqueTypes.push(\n            t === \"null\" || t === null\n              ? NULL\n              : transformSchemaObject(\n                  { ...schemaObject, type: t, oneOf: undefined } as SchemaObject, // donâ€™t stack oneOf transforms\n                  options,\n                ),\n          );\n        }\n      } else {\n        for (const t of schemaObject.type) {\n          if (t === \"null\" || t === null) {\n            uniqueTypes.push(NULL);\n          } else {\n            uniqueTypes.push(transformSchemaObject({ ...schemaObject, type: t } as SchemaObject, options));\n          }\n        }\n      }\n      return tsUnion(uniqueTypes);\n    }\n  }\n\n  // type: object\n  const coreObjectType: ts.TypeElement[] = [];\n\n  // discriminators: explicit mapping on schema object\n  for (const k of [\"allOf\", \"anyOf\"] as const) {\n    if (!schemaObject[k]) {\n      continue;\n    }\n    // for all magic inheritance, we will have already gathered it into\n    // ctx.discriminators. But stop objects from referencing their own\n    // discriminator meant for children (!schemaObject.discriminator)\n    // and don't add discriminator properties if we already added/patched\n    // them (options.ctx.discriminators.refsHandled.includes(options.path!).\n    const discriminator =\n      !schemaObject.discriminator &&\n      !options.ctx.discriminators.refsHandled.includes(options.path ?? \"\") &&\n      options.ctx.discriminators.objects[options.path ?? \"\"];\n    if (discriminator) {\n      coreObjectType.unshift(\n        createDiscriminatorProperty(discriminator, {\n          path: options.path ?? \"\",\n          readonly: options.ctx.immutable,\n        }),\n      );\n      break;\n    }\n  }\n\n  if (\n    (\"properties\" in schemaObject && schemaObject.properties && Object.keys(schemaObject.properties).length) ||\n    (\"additionalProperties\" in schemaObject && schemaObject.additionalProperties) ||\n    (\"$defs\" in schemaObject && schemaObject.$defs)\n  ) {\n    // properties\n    if (Object.keys(schemaObject.properties ?? {}).length) {\n      for (const [k, v] of getEntries(schemaObject.properties ?? {}, options.ctx)) {\n        if ((typeof v !== \"object\" && typeof v !== \"boolean\") || Array.isArray(v)) {\n          throw new Error(\n            `${options.path}: invalid property ${k}. Expected Schema Object or boolean, got ${\n              Array.isArray(v) ? \"Array\" : typeof v\n            }`,\n          );\n        }\n\n        const { $ref, readOnly, hasDefault } =\n          typeof v === \"object\"\n            ? {\n                $ref: \"$ref\" in v && v.$ref,\n                readOnly: \"readOnly\" in v && v.readOnly,\n                hasDefault: \"default\" in v && v.default !== undefined,\n              }\n            : {};\n\n        // handle excludeDeprecated option\n        if (options.ctx.excludeDeprecated) {\n          const resolved = $ref ? options.ctx.resolve<SchemaObject>($ref) : v;\n          if ((resolved as SchemaObject)?.deprecated) {\n            continue;\n          }\n        }\n        let optional =\n          schemaObject.required?.includes(k) ||\n          (schemaObject.required === undefined && options.ctx.propertiesRequiredByDefault) ||\n          (hasDefault &&\n            options.ctx.defaultNonNullable &&\n            !options.path?.includes(\"parameters\") &&\n            !options.path?.includes(\"requestBody\") &&\n            !options.path?.includes(\"requestBodies\")) // canâ€™t be required, even with defaults\n            ? undefined\n            : QUESTION_TOKEN;\n        let type = $ref\n          ? oapiRef($ref)\n          : transformSchemaObject(v, {\n              ...options,\n              path: createRef([options.path, k]),\n            });\n\n        if (typeof options.ctx.transform === \"function\") {\n          const result = options.ctx.transform(v as SchemaObject, options);\n          if (result && typeof result === \"object\") {\n            if (\"schema\" in result) {\n              type = result.schema;\n              optional = result.questionToken ? QUESTION_TOKEN : optional;\n            } else {\n              type = result;\n            }\n          }\n        }\n\n        const property = ts.factory.createPropertySignature(\n          /* modifiers     */ tsModifiers({\n            readonly: options.ctx.immutable || readOnly,\n          }),\n          /* name          */ tsPropertyIndex(k),\n          /* questionToken */ optional,\n          /* type          */ type,\n        );\n        addJSDocComment(v, property);\n        coreObjectType.push(property);\n      }\n    }\n\n    // $defs\n    if (schemaObject.$defs && typeof schemaObject.$defs === \"object\" && Object.keys(schemaObject.$defs).length) {\n      const defKeys: ts.TypeElement[] = [];\n      for (const [k, v] of Object.entries(schemaObject.$defs)) {\n        const property = ts.factory.createPropertySignature(\n          /* modifiers    */ tsModifiers({\n            readonly: options.ctx.immutable || (\"readonly\" in v && !!v.readOnly),\n          }),\n          /* name          */ tsPropertyIndex(k),\n          /* questionToken */ undefined,\n          /* type          */ transformSchemaObject(v, {\n            ...options,\n            path: createRef([options.path, \"$defs\", k]),\n          }),\n        );\n        addJSDocComment(v, property);\n        defKeys.push(property);\n      }\n      coreObjectType.push(\n        ts.factory.createPropertySignature(\n          /* modifiers     */ undefined,\n          /* name          */ tsPropertyIndex(\"$defs\"),\n          /* questionToken */ undefined,\n          /* type          */ ts.factory.createTypeLiteralNode(defKeys),\n        ),\n      );\n    }\n\n    // additionalProperties\n    if (schemaObject.additionalProperties || options.ctx.additionalProperties) {\n      const hasExplicitAdditionalProperties =\n        typeof schemaObject.additionalProperties === \"object\" && Object.keys(schemaObject.additionalProperties).length;\n      const addlType = hasExplicitAdditionalProperties\n        ? transformSchemaObject(schemaObject.additionalProperties as SchemaObject, options)\n        : UNKNOWN;\n      return tsIntersection([\n        ...(coreObjectType.length ? [ts.factory.createTypeLiteralNode(coreObjectType)] : []),\n        ts.factory.createTypeLiteralNode([\n          ts.factory.createIndexSignature(\n            /* modifiers  */ tsModifiers({\n              readonly: options.ctx.immutable,\n            }),\n            /* parameters */ [\n              ts.factory.createParameterDeclaration(\n                /* modifiers      */ undefined,\n                /* dotDotDotToken */ undefined,\n                /* name           */ ts.factory.createIdentifier(\"key\"),\n                /* questionToken  */ undefined,\n                /* type           */ STRING,\n              ),\n            ],\n            /* type       */ addlType,\n          ),\n        ]),\n      ]);\n    }\n  }\n\n  return coreObjectType.length ? ts.factory.createTypeLiteralNode(coreObjectType) : undefined;\n}\n\n/**\n * Check if an object has a key\n * @param possibleObject - The object to check\n * @param key - The key to check for\n * @returns True if the object has the key, false otherwise\n */\nfunction hasKey<K extends string>(possibleObject: unknown, key: K): possibleObject is { [key in K]: unknown } {\n  return typeof possibleObject === \"object\" && possibleObject !== null && key in possibleObject;\n}\n"],"names":["enumType"],"mappings":"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"}
{"version":3,"file":"utils.cjs","sources":["../../src/lib/utils.ts"],"sourcesContent":["import { escapePointer, parseRef } from \"@redocly/openapi-core/lib/ref-utils.js\";\nimport c from \"ansi-colors\";\nimport supportsColor from \"supports-color\";\nimport ts from \"typescript\";\nimport type { DiscriminatorObject, OpenAPI3, OpenAPITSOptions, ReferenceObject, SchemaObject } from \"../types.js\";\nimport { tsLiteral, tsModifiers, tsPropertyIndex } from \"./ts.js\";\n\nif (!supportsColor.stdout || supportsColor.stdout.hasBasic === false) {\n  c.enabled = false;\n}\n\nconst DEBUG_GROUPS: Record<string, c.StyleFunction | undefined> = {\n  redoc: c.cyanBright,\n  lint: c.yellowBright,\n  bundle: c.magentaBright,\n  ts: c.blueBright,\n};\n\nexport { c };\n\n/** Given a discriminator object, get the property name */\nexport function createDiscriminatorProperty(\n  discriminator: DiscriminatorObject,\n  { path, readonly = false }: { path: string; readonly?: boolean },\n): ts.TypeElement {\n  // get the inferred propertyName value from the last section of the path (as the spec suggests to do)\n  let value = parseRef(path).pointer.pop();\n  // if mapping, and there’s a match, use this rather than the inferred name\n  if (discriminator.mapping) {\n    // Mapping value can either be a fully-qualified ref (#/components/schemas/XYZ) or a schema name (XYZ)\n    const matchedValue = Object.entries(discriminator.mapping).find(\n      ([, v]) => (!v.startsWith(\"#\") && v === value) || (v.startsWith(\"#\") && parseRef(v).pointer.pop() === value),\n    );\n    if (matchedValue) {\n      value = matchedValue[0]; // why was this designed backwards!?\n    }\n  }\n  return ts.factory.createPropertySignature(\n    /* modifiers     */ tsModifiers({\n      readonly,\n    }),\n    /* name          */ tsPropertyIndex(discriminator.propertyName),\n    /* questionToken */ undefined,\n    /* type          */ tsLiteral(value),\n  );\n}\n\n/** Create a $ref pointer (even from other $refs) */\nexport function createRef(parts: (number | string | undefined | null)[]): string {\n  let pointer = \"#\";\n  for (const part of parts) {\n    if (part === undefined || part === null || part === \"\") {\n      continue;\n    }\n    const maybeRef = parseRef(String(part)).pointer;\n    if (maybeRef.length) {\n      for (const refPart of maybeRef) {\n        pointer += `/${escapePointer(refPart)}`;\n      }\n    } else {\n      pointer += `/${escapePointer(part)}`;\n    }\n  }\n  return pointer;\n}\n\n/** Print debug message (cribbed from the `debug` package, but without all the bells & whistles */\nexport function debug(msg: string, group?: string, time?: number) {\n  if (\n    process.env.DEBUG &&\n    (!group ||\n      process.env.DEBUG === \"*\" ||\n      process.env.DEBUG === \"openapi-ts:*\" ||\n      process.env.DEBUG.toLocaleLowerCase() === `openapi-ts:${group.toLocaleLowerCase()}`)\n  ) {\n    const groupColor = (group && DEBUG_GROUPS[group]) || c.whiteBright;\n    const groupName = groupColor(`openapi-ts:${group ?? \"info\"}`);\n    let timeFormatted = \"\";\n    if (typeof time === \"number\") {\n      timeFormatted = c.green(` ${formatTime(time)} `);\n    }\n    console.debug(`  ${c.bold(groupName)}${timeFormatted}${msg}`);\n  }\n}\n\n/** Print error message */\nexport function error(msg: string) {\n  console.error(c.red(` ✘  ${msg}`));\n}\n\n/** Format a performance log in a friendly format */\nexport function formatTime(t: number) {\n  if (typeof t === \"number\") {\n    if (t < 1000) {\n      return `${Math.round(10 * t) / 10}ms`;\n    }\n    if (t < 60000) {\n      return `${Math.round(t / 100) / 10}s`;\n    }\n    return `${Math.round(t / 6000) / 10}m`;\n  }\n  return t;\n}\n\n/** Call Object.entries() and optionally sort */\nexport function getEntries<T>(\n  obj: ArrayLike<T> | Record<string, T>,\n  options?: {\n    alphabetize?: boolean;\n    excludeDeprecated?: boolean;\n  },\n) {\n  let entries = Object.entries(obj);\n  if (options?.alphabetize) {\n    entries.sort(([a], [b]) => a.localeCompare(b, \"en-us\", { numeric: true }));\n  }\n  if (options?.excludeDeprecated) {\n    entries = entries.filter(([, v]) => !(v && typeof v === \"object\" && \"deprecated\" in v && v.deprecated));\n  }\n  return entries;\n}\n\n/** resolve a $ref in a schema */\nexport function resolveRef<T>(\n  schema: any,\n  $ref: string,\n  { silent = false, visited = [] }: { silent: boolean; visited?: string[] },\n): T | undefined {\n  const { pointer } = parseRef($ref);\n  if (!pointer.length) {\n    return undefined;\n  }\n  let node = schema;\n  for (const key of pointer) {\n    if (node && typeof node === \"object\" && node[key]) {\n      node = node[key];\n    } else {\n      warn(`Could not resolve $ref \"${$ref}\"`, silent);\n      return undefined;\n    }\n  }\n\n  // if this is also a $ref, keep tracing\n  if (node && typeof node === \"object\" && node.$ref) {\n    if (visited.includes(node.$ref)) {\n      warn(`Could not resolve circular $ref \"${$ref}\"`, silent);\n      return undefined;\n    }\n    return resolveRef(schema, node.$ref, {\n      silent,\n      visited: [...visited, node.$ref],\n    });\n  }\n\n  return node;\n}\n\nfunction createDiscriminatorEnum(values: string[], prevSchema?: SchemaObject): SchemaObject {\n  return {\n    type: \"string\",\n    enum: values,\n    description: prevSchema?.description\n      ? `${prevSchema.description} (enum property replaced by openapi-typescript)`\n      : \"discriminator enum property added by openapi-typescript\",\n  };\n}\n\n/** Adds or replaces the discriminator enum with the passed `values` in a schema defined by `ref` */\nfunction patchDiscriminatorEnum(\n  schema: SchemaObject,\n  ref: string,\n  values: string[],\n  discriminator: DiscriminatorObject,\n  discriminatorRef: string,\n  options: OpenAPITSOptions,\n): boolean {\n  const resolvedSchema = resolveRef<SchemaObject>(schema, ref, {\n    silent: options.silent ?? false,\n  });\n\n  if (resolvedSchema?.allOf) {\n    // if the schema is an allOf, we can append a new schema object to the allOf array\n    resolvedSchema.allOf.push({\n      type: \"object\",\n      // discriminator enum properties always need to be required\n      required: [discriminator.propertyName],\n      properties: {\n        [discriminator.propertyName]: createDiscriminatorEnum(values),\n      },\n    });\n\n    return true;\n  } else if (typeof resolvedSchema === \"object\" && \"type\" in resolvedSchema && resolvedSchema.type === \"object\") {\n    // if the schema is an object, we can apply the discriminator enums to its properties\n    if (!resolvedSchema.properties) {\n      resolvedSchema.properties = {};\n    }\n\n    // discriminator enum properties always need to be required\n    if (!resolvedSchema.required) {\n      resolvedSchema.required = [discriminator.propertyName];\n    } else if (!resolvedSchema.required.includes(discriminator.propertyName)) {\n      resolvedSchema.required.push(discriminator.propertyName);\n    }\n\n    // add/replace the discriminator enum property\n    resolvedSchema.properties[discriminator.propertyName] = createDiscriminatorEnum(\n      values,\n      resolvedSchema.properties[discriminator.propertyName] as SchemaObject,\n    );\n\n    return true;\n  }\n\n  warn(\n    `Discriminator mapping has an invalid schema (neither an object schema nor an allOf array): ${ref} => ${values.join(\n      \", \",\n    )} (Discriminator: ${discriminatorRef})`,\n    options.silent,\n  );\n\n  return false;\n}\n\ntype InternalDiscriminatorMapping = Record<string, { inferred?: string; defined?: string[] }>;\n\n/** Return a key–value map of discriminator objects found in a schema */\nexport function scanDiscriminators(schema: OpenAPI3, options: OpenAPITSOptions) {\n  // all discriminator objects found in the schema\n  const objects: Record<string, DiscriminatorObject> = {};\n\n  // refs of all mapped schema objects we have successfully handled to infer the discriminator enum value\n  const refsHandled: string[] = [];\n\n  // perform 2 passes: first, collect all discriminator definitions and handle oneOf and mappings\n  walk(schema, (obj, path) => {\n    const discriminator = obj?.discriminator as DiscriminatorObject | undefined;\n    if (!discriminator?.propertyName) {\n      return;\n    }\n\n    // collect discriminator object for later usage\n    const ref = createRef(path);\n\n    objects[ref] = discriminator;\n\n    // if a mapping is available we will help Typescript to infer properties by adding the discriminator enum with its single mapped value to each schema\n    // we only handle the mapping in advance for discriminator + oneOf compositions right now\n    if (!obj?.oneOf || !Array.isArray(obj.oneOf)) {\n      return;\n    }\n\n    const oneOf: (SchemaObject | ReferenceObject)[] = obj.oneOf;\n    const mapping: InternalDiscriminatorMapping = {};\n\n    // the mapping can be inferred from the oneOf refs next to the discriminator object\n    for (const item of oneOf) {\n      if (\"$ref\" in item) {\n        // the name of the schema is the inferred discriminator enum value\n        const value = item.$ref.split(\"/\").pop();\n\n        if (value) {\n          if (!mapping[item.$ref]) {\n            mapping[item.$ref] = { inferred: value };\n          } else {\n            mapping[item.$ref].inferred = value;\n          }\n        }\n      }\n    }\n\n    // the mapping can be defined in the discriminator object itself\n    if (discriminator.mapping) {\n      for (const mappedValue in discriminator.mapping) {\n        const mappedRef = discriminator.mapping[mappedValue];\n        if (!mappedRef) {\n          continue;\n        }\n\n        if (!mapping[mappedRef]?.defined) {\n          // this overrides inferred values, but we don't need them anymore as soon as we have a defined value\n          mapping[mappedRef] = { defined: [] };\n        }\n\n        mapping[mappedRef].defined?.push(mappedValue);\n      }\n    }\n\n    for (const [mappedRef, { inferred, defined }] of Object.entries(mapping)) {\n      if (refsHandled.includes(mappedRef)) {\n        continue;\n      }\n\n      if (!inferred && !defined) {\n        continue;\n      }\n\n      // prefer defined values over automatically inferred ones\n      // the inferred enum values from the schema might not represent the actual enum values of the discriminator,\n      // so if we have defined values, use them instead\n      // biome-ignore lint/style/noNonNullAssertion: we just checked for this\n      const mappedValues = defined ?? [inferred!];\n\n      if (\n        patchDiscriminatorEnum(schema as unknown as SchemaObject, mappedRef, mappedValues, discriminator, ref, options)\n      ) {\n        refsHandled.push(mappedRef);\n      }\n    }\n  });\n\n  // second, collect the schema objects that inherit from discriminators\n  // (sometimes this mapping is implicit, so it can’t be done until we know\n  // about every discriminator in the document)\n  walk(schema, (obj, path) => {\n    if (!obj || !Array.isArray(obj.allOf)) {\n      return;\n    }\n\n    for (const item of (obj as any).allOf) {\n      if (\"$ref\" in item) {\n        if (!objects[item.$ref]) {\n          return;\n        }\n\n        const ref = createRef(path);\n        const discriminator = objects[item.$ref];\n        const mappedValues: string[] = [];\n\n        if (discriminator.mapping) {\n          for (const mappedValue in discriminator.mapping) {\n            if (discriminator.mapping[mappedValue] === ref) {\n              mappedValues.push(mappedValue);\n            }\n          }\n\n          if (mappedValues.length > 0) {\n            if (\n              patchDiscriminatorEnum(\n                schema as unknown as SchemaObject,\n                ref,\n                mappedValues,\n                discriminator,\n                item.$ref,\n                options,\n              )\n            ) {\n              refsHandled.push(ref);\n            }\n          }\n        }\n\n        objects[ref] = {\n          ...objects[item.$ref],\n        };\n      } else if (item.discriminator?.propertyName) {\n        objects[createRef(path)] = { ...item.discriminator };\n      }\n    }\n  });\n\n  return { objects, refsHandled };\n}\n\n/** Walk through any JSON-serializable (i.e. non-circular) object */\nexport function walk(\n  obj: unknown,\n  cb: (value: Record<string, unknown>, path: (string | number)[]) => void,\n  path: (string | number)[] = [],\n): void {\n  if (!obj || typeof obj !== \"object\") {\n    return;\n  }\n  if (Array.isArray(obj)) {\n    for (let i = 0; i < obj.length; i++) {\n      walk(obj[i], cb, path.concat(i));\n    }\n    return;\n  }\n  cb(obj as Record<string, unknown>, path);\n  for (const k of Object.keys(obj)) {\n    walk((obj as Record<string, unknown>)[k], cb, path.concat(k));\n  }\n}\n\n/** Print warning message */\nexport function warn(msg: string, silent = false) {\n  if (!silent) {\n    console.warn(c.yellow(` ⚠  ${msg}`));\n  }\n}\n"],"names":["supportsColor","c","parseRef","ts","tsModifiers","tsPropertyIndex","tsLiteral","escapePointer"],"mappings":"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"}